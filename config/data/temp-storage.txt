static final HashMap<String, String> HEADERCONTENTTYPES = new HashMap<String, String>();

    static final String JSON = "json";

    static final String HTML = "html";

    static final String XML = "xml";

    static
    {
        HEADERCONTENTTYPES.put("application/json", JSON);
        HEADERCONTENTTYPES.put("text/json", JSON);
        HEADERCONTENTTYPES.put("text/x-json", JSON);

        HEADERCONTENTTYPES.put("text/xml", XML);
        HEADERCONTENTTYPES.put("application/xml", XML);

        HEADERCONTENTTYPES.put("text/html", HTML);
        HEADERCONTENTTYPES.put("text/application", HTML);

    }
    
    public void validate(final WebResponse response, final HtmlPage page) throws XPathExpressionException
    {
        XltLogger.runTimeLogger.info(getStartValidationMessage());

        final String contentType = getContentTypeOfResponse(response);

        if (HEADERCONTENTTYPES.get(contentType).equals(JSON))
        {
            validateJsonResponse(response);
        }
        else if (HEADERCONTENTTYPES.get(contentType).equals(XML))
        {
            // DO
        }
        else if (HEADERCONTENTTYPES.get(contentType).equals(HTML))
        {
            // Do
        }
        else
        {
            XltLogger.runTimeLogger.warn(getUnsupportedContentTypeMessage(contentType));
        }

    }

    private void validateJsonResponse(final WebResponse response) throws XPathExpressionException
    {
        XltLogger.runTimeLogger.info(getValidateContentTypeMessage(JSON));
        if (getSelectionMode().equalsIgnoreCase(HEADER))
        {
            validateHeaders(response);
        }
        else if (getSelectionMode().equalsIgnoreCase(XPATH))
        {
            validateXPath(createJsonFromResponse(response));
        }
        else if (getSelectionMode().equalsIgnoreCase(REGEXP))
        {
            // TODO
        }
    }

    private JSONObject createJsonFromResponse(final WebResponse response)
    {
        final String jsonString = response.getContentAsString();
        final JSONObject jsonObject = new JSONObject(jsonString);
        return jsonObject;
    }

    private String getContentTypeOfResponse(final WebResponse response)
    {
        XltLogger.runTimeLogger.info(getDetermineContentTypeMessage());
        final String contentType = response.getContentType();
        return contentType;
    }

    public void validateXPath(final WebResponse response) throws XPathExpressionException
    {
        final String contentType = response.getContentType();
        if (HEADERCONTENTTYPES.get(contentType).equals(JSON))
        {
            final String jsonString = response.getContentAsString();
            final JSONObject jsonObject = new JSONObject(jsonString);
            this.validate(jsonObject);
        }
        else if (HEADERCONTENTTYPES.get(contentType).equals(XML))
        {

        }
        else if (HEADERCONTENTTYPES.get(contentType).equals(HTML))
        {

        }
        else
        {
            XltLogger.runTimeLogger.warn("");
        }
    }

    public void validate(final JSONObject jsonObject) throws XPathExpressionException
    {
        if (getSelectionMode().equals(XPATH))
        {
            validateXPath(jsonObject);
        }

    }

    private void validateXPath(final JSONObject jsonObject) throws XPathExpressionException
    {
        XltLogger.runTimeLogger.info(getValidateXPathMessage());

        final String xmlString = org.json.XML.toString(jsonObject);
        final String xml = "<json>" + xmlString + "</json>";

        final XPathFactory xpathFactory = XPathFactory.newInstance();
        final XPath xpath = xpathFactory.newXPath();

        final InputSource source = new InputSource(new StringReader(xml));

        final String status = xpath.evaluate(getSelectionContent(), source);

        if (getValidationMode().equals(EXISTS))
        {
            validateExistance(status);
        }
        else if (getValidationMode().equals(TEXT) || getValidationMode().equals(MATCHES))
        {
            validateText(status);

        }
        else if (getValidationMode().equals(COUNT))
        {
            validateCount(status);

        }

    }

    private void validateExistance(final String status)
    {
        XltLogger.runTimeLogger.info(getValidateExistanceMessage());
        Assert.assertNotNull("XPath not found: <" + getSelectionContent() + ">", status);
    }

    private void validateText(final String status)
    {
        validateExistance(status);
        XltLogger.runTimeLogger.info(getValidateTextMessage(status));
        Assert.assertEquals(MessageFormat.format("Text does not match. Expected:<{0}> but was:<{1}>",
                                                 getValidationContent(), status), status, getValidationContent());
    }

    private void validateCount(final String status)
    {
        validateExistance(status);
        XltLogger.runTimeLogger.info(getValidateCountMessage());
        // TODO
    }

    public void validate(final HtmlPage page)
    {
        XltLogger.runTimeLogger.info(getStartValidationMessage());
        if (getSelectionMode().equals(XPATH))
        {
            validateXPath(page);
        }
        else if (getSelectionMode().equals(REGEXP))
        {
            // XltLogger.runTimeLogger.info(getValidateXPathMessage());
        }
        else if (getSelectionMode().equalsIgnoreCase(HEADER))
        {
            final WebResponse response = page.getWebResponse();
            validateHeaders(response);
        }
    }

    private void validateHeaders(final WebResponse response)
    {
        XltLogger.runTimeLogger.info(getValidateHeaderMessage());
        if (getValidationMode().equals(EXISTS))
        {
            validateExistanceHeader(response);
        }
        else if (getValidationMode().equals(TEXT) || getValidationMode().equals(MATCHES))
        {
            validateTextHeader(response);

        }
        else if (getValidationMode().equals(COUNT))
        {
            validateCountHeader(response);

        }

    }

    private void validateExistanceHeader(final WebResponse response)
    {
        final List<NameValuePair> headers = response.getResponseHeaders();
        boolean exists = false;
        for (final NameValuePair header : headers)
        {
            if (header.getName().equals(getSelectionContent()))
            {
                exists = true;
            }
        }
        Assert.assertTrue(exists);
    }

    private void validateTextHeader(final WebResponse response)
    {
        validateExistanceHeader(response);
        final List<NameValuePair> headers = response.getResponseHeaders();
        for (final NameValuePair header : headers)
        {
            if (header.getName().equals(getSelectionContent()))
            {
                Assert.assertEquals(header.getValue(), getValidationContent());
            }
        }
    }

    private void validateCountHeader(final WebResponse response)
    {
        validateExistanceHeader(response);
        final List<NameValuePair> headers = response.getResponseHeaders();
        int count = 0;
        for (final NameValuePair header : headers)
        {
            if (header.getName().equals(getSelectionContent()))
            {
                count++;
            }
        }
        Assert.assertEquals(Integer.parseInt(getValidationContent()), count);
    }

    @SuppressWarnings("unchecked")
    private void validateXPath(final HtmlPage page)
    {
        XltLogger.runTimeLogger.info(getValidateXPathMessage());
        final List<HtmlElement> elements = (List<HtmlElement>) page.getByXPath(getSelectionContent());

        if (getValidationMode().equals(EXISTS))
        {
            validateExistance(elements);
        }
        else if (getValidationMode().equals(TEXT) || getValidationMode().equals(MATCHES))
        {
            validateText(elements);

        }
        else if (getValidationMode().equals(COUNT))
        {
            validateCount(elements);

        }
    }

    private void validateExistance(final List<HtmlElement> o)
    {
        XltLogger.runTimeLogger.info(getValidateExistanceMessage());
        Assert.assertFalse("[URLActionValidation] Elements not found: <" + getSelectionContent() + ">", o.isEmpty());
    }

    private void validateText(final List<HtmlElement> elements)
    {
        validateExistance(elements);
        final String actual = elements.get(0).asText().trim();
        XltLogger.runTimeLogger.info(getValidateTextMessage(actual));
        System.err.println(getValidationContent());
        System.err.println(actual);
        Assert.assertNotNull(MessageFormat.format("[URLActionValidation] Text does not match. Expected:<{0}> but was:<{1}>",
                                                  getValidationContent(), actual),
                             RegExUtils.getFirstMatch(actual, getValidationContent()));

    }

    private void validateCount(final List<HtmlElement> elements)
    {
        XltLogger.runTimeLogger.info(getValidateCountMessage());
        validateExistance(elements);
        Assert.assertEquals(MessageFormat.format("[URLActionValidation] Expected elements \"{0}\", but was \"{1}\" ",
                                                 getValidationContent(), elements.size()), getValidationContent(),
                            elements.size());
    }