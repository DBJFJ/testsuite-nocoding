package com.xceptance.xlt.common.actions;

import java.io.IOException;
import java.util.List;

import com.gargoylesoftware.htmlunit.FailingHttpStatusCodeException;
import com.gargoylesoftware.htmlunit.Page;
import com.gargoylesoftware.htmlunit.SgmlPage;
import com.gargoylesoftware.htmlunit.WebRequest;
import com.gargoylesoftware.htmlunit.html.HtmlPage;
import com.xceptance.xlt.api.actions.AbstractHtmlPageAction;
import com.xceptance.xlt.api.engine.NetworkData;
import com.xceptance.xlt.api.engine.Session;
import com.xceptance.xlt.api.util.XltProperties;
import com.xceptance.xlt.common.XltConstants;
import com.xceptance.xlt.engine.XltWebClient;

public abstract class ModifiedAbstractHtmlPageAction extends AbstractHtmlPageAction
{
    /**
     * Waiting time property key.
     */
    private static final String PROP_JS_BACKGROUND_ACTIVITY_WAITINGTIME = XltConstants.XLT_PACKAGE_PATH
                                                                          + ".js.backgroundActivity.waitingTime";

    /**
     * Default waiting time value.
     */
    private static final long DEFAULT_JS_BACKGROUND_ACTIVITY_WAITINGTIME = XltProperties.getInstance()
                                                                                        .getProperty(PROP_JS_BACKGROUND_ACTIVITY_WAITINGTIME,
                                                                                                     0);

    /**
     * The parsed HTML page object generated by this action.
     */
    private HtmlPage htmlPage;

    /**
     * Creates a new AbstractHtmlPageAction object and gives it the passed timer name. This constructor is typically
     * used for an intermediate action in a sequence of actions, i.e. it has a previous action.
     * 
     * @param previousAction
     *            the action that preceded the current action
     * @param timerName
     *            the name of the timer that is associated with this action
     */
    protected ModifiedAbstractHtmlPageAction(final ModifiedAbstractHtmlPageAction previousAction,
                                             final String timerName)
    {
        super(previousAction, timerName);
    }

    /**
     * Creates a new AbstractHtmlPageAction object and gives it the passed timer name. This constructor is typically
     * used for the first action in a sequence of actions, i.e. it has no previous action.
     * 
     * @param timerName
     *            the name of the timer that is associated with this action
     */
    protected ModifiedAbstractHtmlPageAction(final String timerName)
    {
        this(null, timerName);
    }

    protected void loadPage(final WebRequest webRequest)
        throws FailingHttpStatusCodeException, IOException
    {
        loadPage(webRequest, DEFAULT_JS_BACKGROUND_ACTIVITY_WAITINGTIME);
    }

    protected void loadPage(final WebRequest webRequest, final long waitingTime)
        throws FailingHttpStatusCodeException, IOException
    {
        final Page result = getWebClient().getPage(webRequest);

        this.htmlPage = waitForPageIsComplete(result, waitingTime);
    }

    private HtmlPage waitForPageIsComplete(final Page page, final long waitingTime)
    {
        // wait for any JavaScript background thread to finish
        if (page instanceof SgmlPage)
        {
            final XltWebClient webClient = (XltWebClient) ((SgmlPage) page).getWebClient();
            webClient.waitForBackgroundThreads(page.getEnclosingWindow().getTopWindow()
                                                   .getEnclosedPage(), waitingTime);
        }

        // something might have changed, including a reload via location
        final HtmlPage newHtmlPage = (HtmlPage) page.getEnclosingWindow().getTopWindow()
                                                    .getEnclosedPage();

        // check for any new static content to load
        ((XltWebClient) newHtmlPage.getWebClient()).loadNewStaticContent(newHtmlPage);

        // Feature #471: API: Make the network data available for validation
        collectAndSetNetworkData();

        return newHtmlPage;
    }

    private List<NetworkData> netStats = null;

    private void collectAndSetNetworkData()
    {
        netStats = Session.getCurrent().getNetworkDataManager().getData();
    }
}
